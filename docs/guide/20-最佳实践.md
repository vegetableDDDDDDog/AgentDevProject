# 💡 最佳实践与开发经验

> LangChain Agent 开发的实战经验总结

---

## 📋 目录

1. [架构设计原则](#架构设计原则)
2. [代码规范](#代码规范)
3. [常见陷阱](#常见陷阱)
4. [调试技巧](#调试技巧)
5. [安全建议](#安全建议)

---

## 🏗️ 架构设计原则

### 1. 单一职责原则

每个 Agent 应该只做一件事：

```python
# ✅ 好的设计
class ChatAgent:
    """专注于对话交互"""

class ToolAgent:
    """专注于工具调用"""

class RAGAgent:
    """专注于知识库检索"""

# ❌ 不好的设计
class SuperAgent:
    """做了所有事情，难以维护"""
```

### 2. 配置与代码分离

使用环境变量管理配置：

```python
# ✅ 好的做法
import os
from dotenv import load_dotenv

load_dotenv()

API_KEY = os.getenv("OPENAI_API_KEY")
API_BASE = os.getenv("OPENAI_API_BASE")
MODEL = os.getenv("OPENAI_MODEL", "glm-4")  # 提供默认值

# ❌ 不好的做法
API_KEY = "80e4f7bd..."  # 硬编码在代码中
```

### 3. 错误处理

始终处理可能的异常：

```python
def query_agent(question: str) -> str:
    try:
        response = agent.query(question)
        return response
    except AttributeError as e:
        return f"⚠️ 工具调用错误: {e}"
    except Exception as e:
        return f"❌ 发生错误: {e}"
```

### 4. 日志记录

添加适当的日志输出：

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def load_documents(path):
    logger.info(f"正在加载文档: {path}")
    # ... 加载逻辑
    logger.info(f"✅ 加载了 {len(documents)} 个文档")
```

---

## 📝 代码规范

### 1. 导入顺序

```python
# 1. 标准库
import os
import sys
from pathlib import Path

# 2. 第三方库
from dotenv import load_dotenv
from langchain_openai import ChatOpenAI

# 3. 本地模块
from agents.chat_agent import SQLiteChatMessageHistory
```

### 2. 类型注解

使用类型提示提高代码可读性：

```python
from typing import List, Optional

def search_documents(
    query: str,
    top_k: int = 3,
    filter_metadata: Optional[dict] = None
) -> List[Document]:
    """检索相关文档

    Args:
        query: 查询文本
        top_k: 返回文档数量
        filter_metadata: 元数据过滤条件

    Returns:
        相关文档列表
    """
    pass
```

### 3. 文档字符串

为函数和类添加清晰的文档：

```python
class RAGAgent:
    """RAG 知识库问答 Agent

    功能：
    - 加载和索引文档
    - 语义检索
    - 增强生成

    示例：
        >>> agent = RAGAgent()
        >>> agent.load_documents("./docs")
        >>> answer = agent.query("问题")
    """

    def query(self, question: str) -> str:
        """查询知识库

        Args:
            question: 用户问题

        Returns:
            AI 生成的回答
        """
        pass
```

### 4. 常量定义

使用常量而非魔法数字：

```python
# ✅ 好的做法
CHUNK_SIZE = 500
CHUNK_OVERLAP = 50
MAX_HISTORY_MESSAGES = 10

text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=CHUNK_SIZE,
    chunk_overlap=CHUNK_OVERLAP,
)

# ❌ 不好的做法
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,  # 这个数字是什么意思？
    chunk_overlap=50,
)
```

---

## ⚠️ 常见陷阱

### 1. 历史过长导致 Token 溢出

**问题：**
```python
# 每次都加载全部历史
messages = get_all_history()  # 可能有几千条
response = llm.invoke(messages)
# ❌ Token 超限错误
```

**解决方案：**
```python
# ✅ 实现自动裁剪
MAX_HISTORY = 10

if len(messages) > MAX_HISTORY:
    # 保留系统消息 + 最近 N 条
    system_msgs = [m for m in messages if isinstance(m, SystemMessage)]
    other_msgs = [m for m in messages if not isinstance(m, SystemMessage)]
    messages = system_msgs + other_msgs[-MAX_HISTORY:]
```

### 2. 工具调用未检查

**问题：**
```python
response = chain.invoke({"input": user_input})
# 直接使用 response.tool_calls
# ❌ 如果没有工具调用会报错
```

**解决方案：**
```python
# ✅ 先检查再使用
if hasattr(response, 'tool_calls') and response.tool_calls:
    for tool_call in response.tool_calls:
        # 执行工具
        pass
else:
    # 正常对话
    pass
```

### 3. 数据库路径问题

**问题：**
```python
# 相对路径在不同位置运行会出错
DB_PATH = "chat_history.db"
conn = sqlite3.connect(DB_PATH)
# ❌ 从 tests/ 目录运行会找不到文件
```

**解决方案：**
```python
# ✅ 使用绝对路径
import os

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
DB_PATH = os.path.join(PROJECT_ROOT, "data", "chat_history.db")
```

### 4. 导入时执行代码

**问题：**
```python
# chat_agent.py

# 全局代码
llm = ChatOpenAI(...)  # ❌ 导入时就创建了
agent = create_agent()  # ❌ 导入时就运行了

def main():
    pass
```

**解决方案：**
```python
# ✅ 延迟到需要时才创建
def main():
    llm = ChatOpenAI(...)
    agent = create_agent(llm)
    # ...

if __name__ == "__main__":
    main()
```

### 5. 提示词中缺少工具说明

**问题：**
```python
# 工具定义了，但 LLM 不知道什么时候用
@tool
def calculator(expression: str) -> str:
    """计算数学表达式"""
    return eval(expression)

# ❌ LLM 可能不调用工具
```

**解决方案：**
```python
# ✅ 在提示词中明确说明
system_prompt = """
你是一个智能助手，可以使用以下工具：
- calculator: 用于数学计算
- get_time: 用于查询当前时间

当用户需要计算时，必须使用 calculator 工具
当用户询问时间时，必须使用 get_time 工具
"""
```

---

## 🐛 调试技巧

### 1. 打印中间结果

```python
def debug_query(question):
    # 1. 打印检索到的文档
    docs = vectorstore.similarity_search(question, k=3)
    print("=== 检索结果 ===")
    for i, doc in enumerate(docs, 1):
        print(f"\n[文档 {i}]")
        print(f"内容: {doc.page_content[:100]}...")
        print(f"相似度: {doc.metadata.get('score', 'N/A')}")

    # 2. 打印提示词
    prompt = prompt_template.format(context=docs, question=question)
    print("\n=== 提示词 ===")
    print(prompt)

    # 3. 打印响应
    response = llm.invoke(prompt)
    print("\n=== 响应 ===")
    print(response.content)
```

### 2. 使用 LangSmith 追踪

```python
import os

# 启用 LangSmith 追踪
os.environ["LANGCHAIN_TRACING_V2"] = "true"
os.environ["LANGCHAIN_API_KEY"] = "your_langsmith_key"

# 现在所有的调用都会被追踪
response = chain.invoke({"input": "test"})
# 在 LangSmith 控制台查看详细执行过程
```

### 3. 分步测试

```python
# ❌ 一次性测试整个流程
def test_full_pipeline():
    result = complex_pipeline()
    assert result  # 出错了，不知道哪里出问题

# ✅ 分步测试
def test_embedding():
    embeddings = embed_documents(["test"])
    assert len(embeddings) == 1

def test_retrieval():
    docs = vectorstore.similarity_search("test")
    assert len(docs) > 0

def test_generation():
    response = llm.invoke("test")
    assert response.content
```

### 4. 使用断言和日志

```python
import logging

logging.basicConfig(level=logging.DEBUG)

def process_documents(docs):
    logger.debug(f"Processing {len(docs)} documents")

    assert all(isinstance(d, Document) for d), "All items must be Document"

    for doc in docs:
        logger.debug(f"Processing: {doc.metadata.get('source')}")

    logger.info("✅ Document processing complete")
```

---

## 🔐 安全建议

### 1. 保护 API Key

```python
# ✅ 使用环境变量
import os
from dotenv import load_dotenv

load_dotenv()
API_KEY = os.getenv("OPENAI_API_KEY")

# ❌ 不要硬编码
API_KEY = "sk-xxx..."  # 绝对不要这样！

# ❌ 不要提交到 Git
# 在 .gitignore 中添加:
.env
```

### 2. 输入验证

```python
def safe_calculator(expression: str) -> str:
    """安全的计算器"""

    # ✅ 验证输入
    import re
    if not re.match(r'^[\d\s+\-*/().]+$', expression):
        return "❌ 输入包含非法字符"

    # 限制长度
    if len(expression) > 100:
        return "❌ 输入过长"

    try:
        result = eval(expression, {"__builtins__": {}}, {})
        return str(result)
    except Exception as e:
        return f"❌ 计算错误: {e}"
```

### 3. 限制资源使用

```python
from functools import lru_cache

# ✅ 缓存结果，避免重复调用
@lru_cache(maxsize=100)
def expensive_operation(query: str):
    # 耗时操作
    return result

# 上下文窗口限制
MAX_TOKENS = 4000
def trim_context(messages):
    total_tokens = sum(len(m.content) for m in messages)
    if total_tokens > MAX_TOKENS:
        # 裁剪
        return messages[-10:]
    return messages
```

### 4. 敏感信息过滤

```python
def filter_secrets(text: str) -> str:
    """过滤敏感信息"""

    import re

    # 移除 API Key
    text = re.sub(r'sk-[a-zA-Z0-9]{32,}', '[REDACTED]', text)

    # 移除邮箱
    text = re.sub(r'\b[\w.-]+@[\w.-]+\.\w+\b', '[EMAIL]', text)

    # 移除手机号
    text = re.sub(r'\b1[3-9]\d{9}\b', '[PHONE]', text)

    return text
```

---

## 📊 性能优化建议

### 1. 批量处理

```python
# ❌ 逐个处理
for text in texts:
    embedding = embeddings.embed_query(text)

# ✅ 批量处理（快 5-10 倍）
embeddings.embed_documents(texts)
```

### 2. 并发请求

```python
from concurrent.futures import ThreadPoolExecutor

def process_multiple_queries(queries):
    with ThreadPoolExecutor(max_workers=5) as executor:
        results = executor.map(agent.query, queries)
    return list(results)
```

### 3. 缓存策略

```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_query(question: str) -> str:
    return agent.query(question)
```

---

## 🎓 推荐阅读

- 📖 [代码速查手册](30-代码速查.md)
- 🔧 [常见问题解答](31-常见问题.md)
- ⚡ [性能优化指南](21-性能优化.md)

---

**遵循这些最佳实践，你的 Agent 将更加健壮、可维护！** 💪
